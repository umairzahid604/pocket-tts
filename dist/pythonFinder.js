"use strict";
/**
 * Multi-version Python detection
 * Finds compatible Python installations (3.10 - 3.14) on the system
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.findAllPythons = findAllPythons;
exports.findBestPython = findBestPython;
exports.findPythonSync = findPythonSync;
const child_process_1 = require("child_process");
// Python commands to try, in priority order (highest version first)
const PYTHON_COMMANDS_UNIX = [
    'python3.14', 'python3.13', 'python3.12', 'python3.11', 'python3.10',
    'python3', 'python'
];
const PYTHON_COMMANDS_WINDOWS = [
    'py -3.14', 'py -3.13', 'py -3.12', 'py -3.11', 'py -3.10',
    'python3.14', 'python3.13', 'python3.12', 'python3.11', 'python3.10',
    'python3', 'python', 'py'
];
const MIN_VERSION = [3, 10];
const MAX_VERSION = [3, 15]; // exclusive
/**
 * Parse Python version string to [major, minor, patch]
 */
function parseVersion(versionStr) {
    const match = versionStr.match(/(\d+)\.(\d+)\.(\d+)/);
    if (!match)
        return null;
    return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
}
/**
 * Check if version is compatible (3.10 <= version < 3.15)
 */
function isCompatibleVersion(version) {
    const [major, minor] = version;
    if (major !== 3)
        return false;
    if (minor < MIN_VERSION[1])
        return false;
    if (minor >= MAX_VERSION[1])
        return false;
    return true;
}
/**
 * Try to get Python info for a given command (async)
 */
async function tryPythonCommand(command) {
    return new Promise((resolve) => {
        try {
            // Build command based on format
            const script = 'import sys; print(sys.version.split()[0]); print(sys.executable)';
            let fullCmd;
            if (command.startsWith('py ')) {
                // Windows py launcher: py -3.11 -c "..."
                fullCmd = `${command} -c "${script}"`;
            }
            else {
                // Regular python command
                fullCmd = `${command} -c "${script}"`;
            }
            const { exec } = require('child_process');
            exec(fullCmd, { timeout: 10000 }, (error, stdout, stderr) => {
                if (error) {
                    resolve(null);
                    return;
                }
                const lines = stdout.trim().split('\n').map((s) => s.trim());
                if (lines.length < 2) {
                    resolve(null);
                    return;
                }
                const version = lines[0];
                const pythonPath = lines[1];
                const parsed = parseVersion(version);
                if (!parsed || !isCompatibleVersion(parsed)) {
                    resolve(null);
                    return;
                }
                resolve({
                    command,
                    version,
                    path: pythonPath,
                    hasPocketTts: false
                });
            });
        }
        catch {
            resolve(null);
        }
    });
}
/**
 * Check if pocket-tts is installed for a given Python command
 */
async function checkPocketTtsInstalled(pythonCommand) {
    return new Promise((resolve) => {
        try {
            const script = "import pocket_tts; print('ok')";
            let fullCmd;
            if (pythonCommand.startsWith('py ')) {
                fullCmd = `${pythonCommand} -c "${script}"`;
            }
            else {
                fullCmd = `${pythonCommand} -c "${script}"`;
            }
            const { exec } = require('child_process');
            exec(fullCmd, { timeout: 15000 }, (error, stdout) => {
                resolve(!error && stdout.includes('ok'));
            });
        }
        catch {
            resolve(false);
        }
    });
}
/**
 * Find all compatible Python installations
 */
async function findAllPythons() {
    const commands = process.platform === 'win32'
        ? PYTHON_COMMANDS_WINDOWS
        : PYTHON_COMMANDS_UNIX;
    const results = [];
    const seenPaths = new Set();
    for (const command of commands) {
        const info = await tryPythonCommand(command);
        if (info && !seenPaths.has(info.path)) {
            // Check if pocket-tts is installed
            info.hasPocketTts = await checkPocketTtsInstalled(command);
            results.push(info);
            seenPaths.add(info.path);
        }
    }
    return results;
}
/**
 * Find the best Python to use
 * Priority: 1) Has pocket-tts installed, 2) Highest version
 */
async function findBestPython() {
    const pythons = await findAllPythons();
    if (pythons.length === 0) {
        return null;
    }
    // First, try to find one with pocket-tts already installed
    const withPocketTts = pythons.filter(p => p.hasPocketTts);
    if (withPocketTts.length > 0) {
        // Return highest version with pocket-tts
        return withPocketTts[0];
    }
    // Otherwise, return highest compatible version
    return pythons[0];
}
/**
 * Quick check if any compatible Python exists (sync version for postinstall)
 */
function findPythonSync() {
    const commands = process.platform === 'win32'
        ? PYTHON_COMMANDS_WINDOWS
        : PYTHON_COMMANDS_UNIX;
    for (const command of commands) {
        try {
            const parts = command.split(' ');
            const cmd = parts[0];
            const args = [...parts.slice(1), '-c', 'import sys; print(sys.version.split()[0])'];
            const result = (0, child_process_1.execSync)(`${cmd} ${args.join(' ')}`, {
                timeout: 5000,
                encoding: 'utf8',
                stdio: ['pipe', 'pipe', 'pipe']
            }).trim();
            const parsed = parseVersion(result);
            if (parsed && isCompatibleVersion(parsed)) {
                return { command, version: result };
            }
        }
        catch {
            // Continue to next command
        }
    }
    return null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHl0aG9uRmluZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3B5dGhvbkZpbmRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOztBQTBISCx3Q0FtQkM7QUFNRCx3Q0FnQkM7QUFLRCx3Q0EyQkM7QUFqTUQsaURBQWdEO0FBSWhELG9FQUFvRTtBQUNwRSxNQUFNLG9CQUFvQixHQUFHO0lBQ3pCLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZO0lBQ3BFLFNBQVMsRUFBRSxRQUFRO0NBQ3RCLENBQUM7QUFFRixNQUFNLHVCQUF1QixHQUFHO0lBQzVCLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVO0lBQzFELFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZO0lBQ3BFLFNBQVMsRUFBRSxRQUFRLEVBQUUsSUFBSTtDQUM1QixDQUFDO0FBRUYsTUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDNUIsTUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZO0FBRXpDOztHQUVHO0FBQ0gsU0FBUyxZQUFZLENBQUMsVUFBa0I7SUFDcEMsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0lBQ3RELElBQUksQ0FBQyxLQUFLO1FBQUUsT0FBTyxJQUFJLENBQUM7SUFDeEIsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEUsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxtQkFBbUIsQ0FBQyxPQUFpQztJQUMxRCxNQUFNLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxHQUFHLE9BQU8sQ0FBQztJQUMvQixJQUFJLEtBQUssS0FBSyxDQUFDO1FBQUUsT0FBTyxLQUFLLENBQUM7SUFDOUIsSUFBSSxLQUFLLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ3pDLElBQUksS0FBSyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFBRSxPQUFPLEtBQUssQ0FBQztJQUMxQyxPQUFPLElBQUksQ0FBQztBQUNoQixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxLQUFLLFVBQVUsZ0JBQWdCLENBQUMsT0FBZTtJQUMzQyxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDM0IsSUFBSSxDQUFDO1lBQ0QsZ0NBQWdDO1lBQ2hDLE1BQU0sTUFBTSxHQUFHLGtFQUFrRSxDQUFDO1lBQ2xGLElBQUksT0FBZSxDQUFDO1lBRXBCLElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUM1Qix5Q0FBeUM7Z0JBQ3pDLE9BQU8sR0FBRyxHQUFHLE9BQU8sUUFBUSxNQUFNLEdBQUcsQ0FBQztZQUMxQyxDQUFDO2lCQUFNLENBQUM7Z0JBQ0oseUJBQXlCO2dCQUN6QixPQUFPLEdBQUcsR0FBRyxPQUFPLFFBQVEsTUFBTSxHQUFHLENBQUM7WUFDMUMsQ0FBQztZQUVELE1BQU0sRUFBRSxJQUFJLEVBQUUsR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDMUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQW1CLEVBQUUsTUFBYyxFQUFFLE1BQWMsRUFBRSxFQUFFO2dCQUN0RixJQUFJLEtBQUssRUFBRSxDQUFDO29CQUNSLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDZCxPQUFPO2dCQUNYLENBQUM7Z0JBRUQsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFTLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO2dCQUNyRSxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7b0JBQ25CLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDZCxPQUFPO2dCQUNYLENBQUM7Z0JBRUQsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN6QixNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBRTVCLE1BQU0sTUFBTSxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDckMsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7b0JBQzFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDZCxPQUFPO2dCQUNYLENBQUM7Z0JBRUQsT0FBTyxDQUFDO29CQUNKLE9BQU87b0JBQ1AsT0FBTztvQkFDUCxJQUFJLEVBQUUsVUFBVTtvQkFDaEIsWUFBWSxFQUFFLEtBQUs7aUJBQ3RCLENBQUMsQ0FBQztZQUNQLENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQztRQUFDLE1BQU0sQ0FBQztZQUNMLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsQixDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxLQUFLLFVBQVUsdUJBQXVCLENBQUMsYUFBcUI7SUFDeEQsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO1FBQzNCLElBQUksQ0FBQztZQUNELE1BQU0sTUFBTSxHQUFHLGdDQUFnQyxDQUFDO1lBQ2hELElBQUksT0FBZSxDQUFDO1lBRXBCLElBQUksYUFBYSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUNsQyxPQUFPLEdBQUcsR0FBRyxhQUFhLFFBQVEsTUFBTSxHQUFHLENBQUM7WUFDaEQsQ0FBQztpQkFBTSxDQUFDO2dCQUNKLE9BQU8sR0FBRyxHQUFHLGFBQWEsUUFBUSxNQUFNLEdBQUcsQ0FBQztZQUNoRCxDQUFDO1lBRUQsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUMxQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBbUIsRUFBRSxNQUFjLEVBQUUsRUFBRTtnQkFDdEUsT0FBTyxDQUFDLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM3QyxDQUFDLENBQUMsQ0FBQztRQUNQLENBQUM7UUFBQyxNQUFNLENBQUM7WUFDTCxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbkIsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQztBQUVEOztHQUVHO0FBQ0ksS0FBSyxVQUFVLGNBQWM7SUFDaEMsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPO1FBQ3pDLENBQUMsQ0FBQyx1QkFBdUI7UUFDekIsQ0FBQyxDQUFDLG9CQUFvQixDQUFDO0lBRTNCLE1BQU0sT0FBTyxHQUFpQixFQUFFLENBQUM7SUFDakMsTUFBTSxTQUFTLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztJQUVwQyxLQUFLLE1BQU0sT0FBTyxJQUFJLFFBQVEsRUFBRSxDQUFDO1FBQzdCLE1BQU0sSUFBSSxHQUFHLE1BQU0sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDN0MsSUFBSSxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1lBQ3BDLG1DQUFtQztZQUNuQyxJQUFJLENBQUMsWUFBWSxHQUFHLE1BQU0sdUJBQXVCLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDM0QsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNuQixTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QixDQUFDO0lBQ0wsQ0FBQztJQUVELE9BQU8sT0FBTyxDQUFDO0FBQ25CLENBQUM7QUFFRDs7O0dBR0c7QUFDSSxLQUFLLFVBQVUsY0FBYztJQUNoQyxNQUFNLE9BQU8sR0FBRyxNQUFNLGNBQWMsRUFBRSxDQUFDO0lBRXZDLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUN2QixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsMkRBQTJEO0lBQzNELE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDMUQsSUFBSSxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQzNCLHlDQUF5QztRQUN6QyxPQUFPLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQsK0NBQStDO0lBQy9DLE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RCLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLGNBQWM7SUFDMUIsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPO1FBQ3pDLENBQUMsQ0FBQyx1QkFBdUI7UUFDekIsQ0FBQyxDQUFDLG9CQUFvQixDQUFDO0lBRTNCLEtBQUssTUFBTSxPQUFPLElBQUksUUFBUSxFQUFFLENBQUM7UUFDN0IsSUFBSSxDQUFDO1lBQ0QsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQyxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckIsTUFBTSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLDJDQUEyQyxDQUFDLENBQUM7WUFFcEYsTUFBTSxNQUFNLEdBQUcsSUFBQSx3QkFBUSxFQUFDLEdBQUcsR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRTtnQkFDaEQsT0FBTyxFQUFFLElBQUk7Z0JBQ2IsUUFBUSxFQUFFLE1BQU07Z0JBQ2hCLEtBQUssRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDO2FBQ2xDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUVWLE1BQU0sTUFBTSxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNwQyxJQUFJLE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO2dCQUN4QyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQztZQUN4QyxDQUFDO1FBQ0wsQ0FBQztRQUFDLE1BQU0sQ0FBQztZQUNMLDJCQUEyQjtRQUMvQixDQUFDO0lBQ0wsQ0FBQztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogTXVsdGktdmVyc2lvbiBQeXRob24gZGV0ZWN0aW9uXHJcbiAqIEZpbmRzIGNvbXBhdGlibGUgUHl0aG9uIGluc3RhbGxhdGlvbnMgKDMuMTAgLSAzLjE0KSBvbiB0aGUgc3lzdGVtXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgc3Bhd24sIGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7IFB5dGhvbkluZm8gfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbi8vIFB5dGhvbiBjb21tYW5kcyB0byB0cnksIGluIHByaW9yaXR5IG9yZGVyIChoaWdoZXN0IHZlcnNpb24gZmlyc3QpXHJcbmNvbnN0IFBZVEhPTl9DT01NQU5EU19VTklYID0gW1xyXG4gICAgJ3B5dGhvbjMuMTQnLCAncHl0aG9uMy4xMycsICdweXRob24zLjEyJywgJ3B5dGhvbjMuMTEnLCAncHl0aG9uMy4xMCcsXHJcbiAgICAncHl0aG9uMycsICdweXRob24nXHJcbl07XHJcblxyXG5jb25zdCBQWVRIT05fQ09NTUFORFNfV0lORE9XUyA9IFtcclxuICAgICdweSAtMy4xNCcsICdweSAtMy4xMycsICdweSAtMy4xMicsICdweSAtMy4xMScsICdweSAtMy4xMCcsXHJcbiAgICAncHl0aG9uMy4xNCcsICdweXRob24zLjEzJywgJ3B5dGhvbjMuMTInLCAncHl0aG9uMy4xMScsICdweXRob24zLjEwJyxcclxuICAgICdweXRob24zJywgJ3B5dGhvbicsICdweSdcclxuXTtcclxuXHJcbmNvbnN0IE1JTl9WRVJTSU9OID0gWzMsIDEwXTtcclxuY29uc3QgTUFYX1ZFUlNJT04gPSBbMywgMTVdOyAvLyBleGNsdXNpdmVcclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBQeXRob24gdmVyc2lvbiBzdHJpbmcgdG8gW21ham9yLCBtaW5vciwgcGF0Y2hdXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVZlcnNpb24odmVyc2lvblN0cjogc3RyaW5nKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHwgbnVsbCB7XHJcbiAgICBjb25zdCBtYXRjaCA9IHZlcnNpb25TdHIubWF0Y2goLyhcXGQrKVxcLihcXGQrKVxcLihcXGQrKS8pO1xyXG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gW3BhcnNlSW50KG1hdGNoWzFdKSwgcGFyc2VJbnQobWF0Y2hbMl0pLCBwYXJzZUludChtYXRjaFszXSldO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdmVyc2lvbiBpcyBjb21wYXRpYmxlICgzLjEwIDw9IHZlcnNpb24gPCAzLjE1KVxyXG4gKi9cclxuZnVuY3Rpb24gaXNDb21wYXRpYmxlVmVyc2lvbih2ZXJzaW9uOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBib29sZWFuIHtcclxuICAgIGNvbnN0IFttYWpvciwgbWlub3JdID0gdmVyc2lvbjtcclxuICAgIGlmIChtYWpvciAhPT0gMykgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKG1pbm9yIDwgTUlOX1ZFUlNJT05bMV0pIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChtaW5vciA+PSBNQVhfVkVSU0lPTlsxXSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcnkgdG8gZ2V0IFB5dGhvbiBpbmZvIGZvciBhIGdpdmVuIGNvbW1hbmQgKGFzeW5jKVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdHJ5UHl0aG9uQ29tbWFuZChjb21tYW5kOiBzdHJpbmcpOiBQcm9taXNlPFB5dGhvbkluZm8gfCBudWxsPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBCdWlsZCBjb21tYW5kIGJhc2VkIG9uIGZvcm1hdFxyXG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSAnaW1wb3J0IHN5czsgcHJpbnQoc3lzLnZlcnNpb24uc3BsaXQoKVswXSk7IHByaW50KHN5cy5leGVjdXRhYmxlKSc7XHJcbiAgICAgICAgICAgIGxldCBmdWxsQ21kOiBzdHJpbmc7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29tbWFuZC5zdGFydHNXaXRoKCdweSAnKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2luZG93cyBweSBsYXVuY2hlcjogcHkgLTMuMTEgLWMgXCIuLi5cIlxyXG4gICAgICAgICAgICAgICAgZnVsbENtZCA9IGAke2NvbW1hbmR9IC1jIFwiJHtzY3JpcHR9XCJgO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVndWxhciBweXRob24gY29tbWFuZFxyXG4gICAgICAgICAgICAgICAgZnVsbENtZCA9IGAke2NvbW1hbmR9IC1jIFwiJHtzY3JpcHR9XCJgO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCB7IGV4ZWMgfSA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcclxuICAgICAgICAgICAgZXhlYyhmdWxsQ21kLCB7IHRpbWVvdXQ6IDEwMDAwIH0sIChlcnJvcjogRXJyb3IgfCBudWxsLCBzdGRvdXQ6IHN0cmluZywgc3RkZXJyOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRyaW0oKS5zcGxpdCgnXFxuJykubWFwKChzOiBzdHJpbmcpID0+IHMudHJpbSgpKTtcclxuICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IGxpbmVzWzBdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHl0aG9uUGF0aCA9IGxpbmVzWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlVmVyc2lvbih2ZXJzaW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkIHx8ICFpc0NvbXBhdGlibGVWZXJzaW9uKHBhcnNlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcHl0aG9uUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBoYXNQb2NrZXRUdHM6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBwb2NrZXQtdHRzIGlzIGluc3RhbGxlZCBmb3IgYSBnaXZlbiBQeXRob24gY29tbWFuZFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gY2hlY2tQb2NrZXRUdHNJbnN0YWxsZWQocHl0aG9uQ29tbWFuZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSBcImltcG9ydCBwb2NrZXRfdHRzOyBwcmludCgnb2snKVwiO1xyXG4gICAgICAgICAgICBsZXQgZnVsbENtZDogc3RyaW5nO1xyXG5cclxuICAgICAgICAgICAgaWYgKHB5dGhvbkNvbW1hbmQuc3RhcnRzV2l0aCgncHkgJykpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGxDbWQgPSBgJHtweXRob25Db21tYW5kfSAtYyBcIiR7c2NyaXB0fVwiYDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZ1bGxDbWQgPSBgJHtweXRob25Db21tYW5kfSAtYyBcIiR7c2NyaXB0fVwiYDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgeyBleGVjIH0gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XHJcbiAgICAgICAgICAgIGV4ZWMoZnVsbENtZCwgeyB0aW1lb3V0OiAxNTAwMCB9LCAoZXJyb3I6IEVycm9yIHwgbnVsbCwgc3Rkb3V0OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoIWVycm9yICYmIHN0ZG91dC5pbmNsdWRlcygnb2snKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmQgYWxsIGNvbXBhdGlibGUgUHl0aG9uIGluc3RhbGxhdGlvbnNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaW5kQWxsUHl0aG9ucygpOiBQcm9taXNlPFB5dGhvbkluZm9bXT4ge1xyXG4gICAgY29uc3QgY29tbWFuZHMgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXHJcbiAgICAgICAgPyBQWVRIT05fQ09NTUFORFNfV0lORE9XU1xyXG4gICAgICAgIDogUFlUSE9OX0NPTU1BTkRTX1VOSVg7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0czogUHl0aG9uSW5mb1tdID0gW107XHJcbiAgICBjb25zdCBzZWVuUGF0aHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgY29tbWFuZHMpIHtcclxuICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQgdHJ5UHl0aG9uQ29tbWFuZChjb21tYW5kKTtcclxuICAgICAgICBpZiAoaW5mbyAmJiAhc2VlblBhdGhzLmhhcyhpbmZvLnBhdGgpKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHBvY2tldC10dHMgaXMgaW5zdGFsbGVkXHJcbiAgICAgICAgICAgIGluZm8uaGFzUG9ja2V0VHRzID0gYXdhaXQgY2hlY2tQb2NrZXRUdHNJbnN0YWxsZWQoY29tbWFuZCk7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpbmZvKTtcclxuICAgICAgICAgICAgc2VlblBhdGhzLmFkZChpbmZvLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIGJlc3QgUHl0aG9uIHRvIHVzZVxyXG4gKiBQcmlvcml0eTogMSkgSGFzIHBvY2tldC10dHMgaW5zdGFsbGVkLCAyKSBIaWdoZXN0IHZlcnNpb25cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaW5kQmVzdFB5dGhvbigpOiBQcm9taXNlPFB5dGhvbkluZm8gfCBudWxsPiB7XHJcbiAgICBjb25zdCBweXRob25zID0gYXdhaXQgZmluZEFsbFB5dGhvbnMoKTtcclxuXHJcbiAgICBpZiAocHl0aG9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaXJzdCwgdHJ5IHRvIGZpbmQgb25lIHdpdGggcG9ja2V0LXR0cyBhbHJlYWR5IGluc3RhbGxlZFxyXG4gICAgY29uc3Qgd2l0aFBvY2tldFR0cyA9IHB5dGhvbnMuZmlsdGVyKHAgPT4gcC5oYXNQb2NrZXRUdHMpO1xyXG4gICAgaWYgKHdpdGhQb2NrZXRUdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIFJldHVybiBoaWdoZXN0IHZlcnNpb24gd2l0aCBwb2NrZXQtdHRzXHJcbiAgICAgICAgcmV0dXJuIHdpdGhQb2NrZXRUdHNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gaGlnaGVzdCBjb21wYXRpYmxlIHZlcnNpb25cclxuICAgIHJldHVybiBweXRob25zWzBdO1xyXG59XHJcblxyXG4vKipcclxuICogUXVpY2sgY2hlY2sgaWYgYW55IGNvbXBhdGlibGUgUHl0aG9uIGV4aXN0cyAoc3luYyB2ZXJzaW9uIGZvciBwb3N0aW5zdGFsbClcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kUHl0aG9uU3luYygpOiB7IGNvbW1hbmQ6IHN0cmluZzsgdmVyc2lvbjogc3RyaW5nIH0gfCBudWxsIHtcclxuICAgIGNvbnN0IGNvbW1hbmRzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xyXG4gICAgICAgID8gUFlUSE9OX0NPTU1BTkRTX1dJTkRPV1NcclxuICAgICAgICA6IFBZVEhPTl9DT01NQU5EU19VTklYO1xyXG5cclxuICAgIGZvciAoY29uc3QgY29tbWFuZCBvZiBjb21tYW5kcykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gY29tbWFuZC5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICBjb25zdCBjbWQgPSBwYXJ0c1swXTtcclxuICAgICAgICAgICAgY29uc3QgYXJncyA9IFsuLi5wYXJ0cy5zbGljZSgxKSwgJy1jJywgJ2ltcG9ydCBzeXM7IHByaW50KHN5cy52ZXJzaW9uLnNwbGl0KClbMF0pJ107XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBleGVjU3luYyhgJHtjbWR9ICR7YXJncy5qb2luKCcgJyl9YCwge1xyXG4gICAgICAgICAgICAgICAgdGltZW91dDogNTAwMCxcclxuICAgICAgICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXHJcbiAgICAgICAgICAgICAgICBzdGRpbzogWydwaXBlJywgJ3BpcGUnLCAncGlwZSddXHJcbiAgICAgICAgICAgIH0pLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlVmVyc2lvbihyZXN1bHQpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkICYmIGlzQ29tcGF0aWJsZVZlcnNpb24ocGFyc2VkKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29tbWFuZCwgdmVyc2lvbjogcmVzdWx0IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgLy8gQ29udGludWUgdG8gbmV4dCBjb21tYW5kXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbiJdfQ==